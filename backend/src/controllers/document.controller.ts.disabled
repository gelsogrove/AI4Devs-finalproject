import { PrismaClient } from '@prisma/client';
import { Request, Response } from 'express';
import multer from 'multer';
import { v4 as uuidv4 } from 'uuid';
import { z } from 'zod';
import { Document, DocumentStatus } from '../domain/entities/Document';
import { DocumentRepository } from '../infrastructure/repositories/DocumentRepository';
import { pdfProcessingService } from '../services/pdf-processing.service';
import { storageService } from '../services/storage.service';
import logger from '../utils/logger';

const prisma = new PrismaClient();

// Validation schemas
const uploadDocumentSchema = z.object({
  title: z.string().optional(),
  path: z.string().optional()
});

const searchDocumentsSchema = z.object({
  query: z.string().optional(),
  limit: z.number().min(1).max(50).optional().default(10),
  offset: z.number().min(0).optional().default(0)
});

// Multer configuration for file upload
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: parseInt(process.env.MAX_FILE_SIZE || '10485760'), // 10MB default
    files: 1
  },
  fileFilter: (req, file, cb) => {
    // Validate file type
    if (file.mimetype !== 'application/pdf') {
      return cb(new Error('Only PDF files are allowed'));
    }
    cb(null, true);
  }
});

export class DocumentController {
  private documentRepository: DocumentRepository;

  constructor() {
    this.documentRepository = new DocumentRepository(prisma);
  }

  /**
   * Upload a new document
   */
  uploadDocument = [
    upload.single('document'),
    async (req: Request, res: Response) => {
      try {
        if (!req.file) {
          return res.status(400).json({ error: 'No file uploaded' });
        }

        // Validate request body
        const { title, path: documentPath } = uploadDocumentSchema.parse(req.body);

        // Validate PDF
        const isValidPDF = await pdfProcessingService.validatePDF(req.file.buffer);
        if (!isValidPDF) {
          return res.status(400).json({ error: 'Invalid PDF file' });
        }

        // Create document entity
        const documentId = uuidv4();
        
        // Upload file to storage
        const uploadResult = await storageService.uploadFile(
          req.file.buffer,
          req.file.originalname,
          req.file.mimetype
        );

        // Extract PDF content and metadata
        const processedDocument = await pdfProcessingService.extractTextFromPDF(req.file.buffer);

        // Determine title (user input > PDF metadata > filename)
        const documentTitle = title || 
                             processedDocument.metadata.title || 
                             req.file.originalname.replace('.pdf', '');

        // Create document entity
        const document = new Document(
          documentId,
          uploadResult.filename,
          req.file.originalname,
          req.file.mimetype,
          uploadResult.size,
          uploadResult.path,
          DocumentStatus.PROCESSING,
          req.user?.userId, // From auth middleware
          processedDocument.metadata,
          new Date(),
          new Date()
        );

        // Save to database
        const savedDocument = await this.documentRepository.create(document);

        // Process chunks and generate embeddings (async)
        this.processDocumentChunks(documentId, processedDocument.chunks)
          .catch(error => logger.error('Error processing document chunks:', error));

        // Update document with title and path
        if (documentTitle || documentPath) {
          await prisma.document.update({
            where: { id: documentId },
            data: {
              title: documentTitle,
              path: documentPath
            }
          });
        }

        logger.info(`Document uploaded successfully: ${req.file.originalname}`);

        res.status(201).json({
          message: 'Document uploaded successfully',
          document: {
            id: savedDocument.id,
            filename: savedDocument.filename,
            originalName: savedDocument.originalName,
            title: documentTitle,
            path: documentPath,
            size: savedDocument.size,
            status: savedDocument.status,
            createdAt: savedDocument.createdAt
          }
        });

      } catch (error) {
        logger.error('Document upload error:', error);
        
        if (error instanceof z.ZodError) {
          return res.status(400).json({
            error: 'Validation error',
            details: error.errors
          });
        }

        if (error instanceof multer.MulterError) {
          if (error.code === 'LIMIT_FILE_SIZE') {
            return res.status(400).json({ error: 'File too large' });
          }
          return res.status(400).json({ error: error.message });
        }

        res.status(500).json({ error: 'Failed to upload document' });
      }
    }
  ];

  /**
   * Get all documents for the current user
   */
  getDocuments = async (req: Request, res: Response) => {
    try {
      const { limit, offset } = searchDocumentsSchema.parse(req.query);
      
      const documents = await prisma.document.findMany({
        where: { userId: req.user?.userId || null },
        orderBy: { createdAt: 'desc' },
        take: limit,
        skip: offset
      });

      // Get total count
      const totalCount = await prisma.document.count({
        where: { userId: req.user?.userId || null }
      });

      res.json({
        documents: documents.map(doc => ({
          id: doc.id,
          filename: doc.filename,
          originalName: doc.originalName,
          title: doc.title || doc.originalName,
          path: doc.path || '',
          size: doc.size,
          status: doc.status,
          metadata: doc.metadata ? JSON.parse(doc.metadata) : null,
          createdAt: doc.createdAt,
          updatedAt: doc.updatedAt
        })),
        pagination: {
          total: totalCount,
          limit,
          offset,
          hasMore: offset + limit < totalCount
        }
      });

    } catch (error) {
      logger.error('Error fetching documents:', error);
      res.status(500).json({ error: 'Failed to fetch documents' });
    }
  };

  /**
   * Get document by ID
   */
  getDocumentById = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      
      const document = await prisma.document.findUnique({
        where: { id }
      });
      
      if (!document) {
        return res.status(404).json({ error: 'Document not found' });
      }

      // Check ownership
      if (document.userId && document.userId !== req.user?.userId) {
        return res.status(403).json({ error: 'Access denied' });
      }

      res.json({
        id: document.id,
        filename: document.filename,
        originalName: document.originalName,
        title: document.title || document.originalName,
        path: document.path || '',
        size: document.size,
        status: document.status,
        metadata: document.metadata ? JSON.parse(document.metadata) : null,
        createdAt: document.createdAt,
        updatedAt: document.updatedAt
      });

    } catch (error) {
      logger.error('Error fetching document:', error);
      res.status(500).json({ error: 'Failed to fetch document' });
    }
  };

  /**
   * Delete document
   */
  deleteDocument = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      
      const document = await prisma.document.findUnique({
        where: { id }
      });
      
      if (!document) {
        return res.status(404).json({ error: 'Document not found' });
      }

      // Check ownership
      if (document.userId && document.userId !== req.user?.userId) {
        return res.status(403).json({ error: 'Access denied' });
      }

      // Delete file from storage
      try {
        await storageService.deleteFile(document.uploadPath);
      } catch (error) {
        logger.warn('Failed to delete file from storage:', error);
      }

      // Delete from database
      await prisma.document.delete({
        where: { id }
      });

      logger.info(`Document deleted: ${document.originalName}`);
      res.json({ message: 'Document deleted successfully' });

    } catch (error) {
      logger.error('Error deleting document:', error);
      res.status(500).json({ error: 'Failed to delete document' });
    }
  };

  /**
   * Search documents
   */
  searchDocuments = async (req: Request, res: Response) => {
    try {
      const { query, limit, offset } = searchDocumentsSchema.parse(req.query);
      
      if (!query) {
        return this.getDocuments(req, res);
      }

      // Simple text search in title, originalName, and metadata (SQLite compatible)
      const documents = await prisma.document.findMany({
        where: {
          userId: req.user?.userId || null,
          OR: [
            { title: { contains: query } },
            { originalName: { contains: query } },
            { metadata: { contains: query } }
          ]
        },
        orderBy: { createdAt: 'desc' },
        take: limit,
        skip: offset
      });

      const totalCount = await prisma.document.count({
        where: {
          userId: req.user?.userId || null,
          OR: [
            { title: { contains: query } },
            { originalName: { contains: query } },
            { metadata: { contains: query } }
          ]
        }
      });

      res.json({
        documents: documents.map((doc: any) => ({
          id: doc.id,
          filename: doc.filename,
          originalName: doc.originalName,
          title: doc.title || doc.originalName,
          path: doc.path || '',
          size: doc.size,
          status: doc.status,
          metadata: doc.metadata ? JSON.parse(doc.metadata) : null,
          createdAt: doc.createdAt,
          updatedAt: doc.updatedAt
        })),
        pagination: {
          total: totalCount,
          limit,
          offset,
          hasMore: offset + limit < totalCount
        },
        query
      });

    } catch (error) {
      logger.error('Error searching documents:', error);
      res.status(500).json({ error: 'Failed to search documents' });
    }
  };

  /**
   * Get document statistics
   */
  getDocumentStats = async (req: Request, res: Response) => {
    try {
      const userId = req.user?.userId;
      
      const stats = await prisma.document.aggregate({
        where: { userId: userId || null },
        _count: { id: true },
        _sum: { size: true }
      });

      const statusCounts = await prisma.document.groupBy({
        by: ['status'],
        where: { userId: userId || null },
        _count: { status: true }
      });

      res.json({
        totalDocuments: stats._count.id || 0,
        totalSize: stats._sum.size || 0,
        statusBreakdown: statusCounts.reduce((acc: any, item: any) => {
          acc[item.status] = item._count.status;
          return acc;
        }, {} as Record<string, number>)
      });

    } catch (error) {
      logger.error('Error fetching document stats:', error);
      res.status(500).json({ error: 'Failed to fetch document statistics' });
    }
  };

  /**
   * Process document chunks and generate embeddings (async)
   */
  private async processDocumentChunks(documentId: string, chunks: any[]) {
    try {
      // Generate embeddings for chunks
      const chunksWithEmbeddings = await pdfProcessingService.generateEmbeddingsForChunks(chunks);
      
      // Save chunks to database
      const chunkData = chunksWithEmbeddings.map((chunk, index) => ({
        id: uuidv4(),
        content: chunk.content,
        pageNumber: chunk.pageNumber,
        chunkIndex: index,
        embedding: chunk.embedding
      }));

      await this.documentRepository.createChunks(documentId, chunkData);

      // Update document status to completed
      await this.documentRepository.updateStatus(documentId, DocumentStatus.COMPLETED);

      logger.info(`Document processing completed: ${documentId}`);

    } catch (error) {
      logger.error(`Error processing document ${documentId}:`, error);
      
      // Update document status to failed
      await this.documentRepository.updateStatus(documentId, DocumentStatus.FAILED);
    }
  }
}

export default new DocumentController(); 