# Terraform Infrastructure Deployment for ShopMefy
# This workflow creates complete AWS infrastructure for production environment
# 
# CONFIGURATION SUMMARY:
# - Cloud Provider: AWS
# - Environment: Production only
# - Database: RDS PostgreSQL managed with automatic backups
# - App Server: 1 EC2 t3.micro instance (scalable to t3.small)
# - Access: Public IP only (no custom domain)
# - Security: Basic Security Groups (SSH, HTTP, HTTPS, PostgreSQL)
# - Storage: S3 bucket for deployments + RDS backups
# - EC2 Setup: Pre-configured with Node.js, PM2, Nginx, user 'shopme'
# - Secrets: AWS Secrets Manager for database credentials
# - Monitoring: CloudWatch basic logging only
# - Deploy Flow: CI/CD â†’ S3 â†’ EC2 (compatible with existing deploy.yml)
# - Estimated Cost: ~$27-30/month

name: ðŸš€ Deploy AWS Infrastructure with Terraform

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform Action'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy
      instance_type:
        description: 'EC2 Instance Type'
        required: true
        default: 't3.micro'
        type: choice
        options:
          - t3.micro
          - t3.small
          - t3.medium

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0

jobs:
  terraform:
    name: ðŸ—ï¸ Terraform Infrastructure
    runs-on: ubuntu-latest
    environment: prod
    
    defaults:
      run:
        working-directory: ./terraform
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: âš™ï¸ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ðŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: ðŸ“ Create Terraform Directory
        run: |
          mkdir -p ../terraform
          cd ../terraform

      - name: ðŸ“ Generate Terraform Configuration
        run: |
          cat > main.tf << 'EOF'
          # ===================================
          # SHOPMEFY AWS INFRASTRUCTURE
          # ===================================
          
          terraform {
            required_version = ">= 1.0"
            required_providers {
              aws = {
                source  = "hashicorp/aws"
                version = "~> 5.0"
              }
              random = {
                source  = "hashicorp/random"
                version = "~> 3.1"
              }
            }
          }
          
          provider "aws" {
            region = var.aws_region
            
            default_tags {
              tags = {
                Project     = "ShopMefy"
                Environment = "production"
                ManagedBy   = "Terraform"
                Owner       = "Andrea"
              }
            }
          }
          
          # ===================================
          # VARIABLES
          # ===================================
          
          variable "aws_region" {
            description = "AWS region"
            type        = string
            default     = "us-east-1"
          }
          
          variable "instance_type" {
            description = "EC2 instance type"
            type        = string
            default     = "t3.micro"
          }
          
          variable "project_name" {
            description = "Project name"
            type        = string
            default     = "shopmefy"
          }
          
          # ===================================
          # DATA SOURCES
          # ===================================
          
          data "aws_availability_zones" "available" {
            state = "available"
          }
          
          data "aws_ami" "ubuntu" {
            most_recent = true
            owners      = ["099720109477"] # Canonical
            
            filter {
              name   = "name"
              values = ["ubuntu/images/hvm-ssd/ubuntu-22.04-amd64-server-*"]
            }
            
            filter {
              name   = "virtualization-type"
              values = ["hvm"]
            }
          }
          
          # ===================================
          # RANDOM PASSWORD FOR DATABASE
          # ===================================
          
          resource "random_password" "db_password" {
            length  = 16
            special = true
          }
          
          # ===================================
          # AWS SECRETS MANAGER
          # ===================================
          
          resource "aws_secretsmanager_secret" "db_credentials" {
            name                    = "${var.project_name}-db-credentials"
            description             = "Database credentials for ShopMefy"
            recovery_window_in_days = 7
          }
          
          resource "aws_secretsmanager_secret_version" "db_credentials" {
            secret_id = aws_secretsmanager_secret.db_credentials.id
            secret_string = jsonencode({
              username = "shopmefy"
              password = random_password.db_password.result
              engine   = "postgres"
              host     = aws_db_instance.postgres.endpoint
              port     = 5432
              dbname   = "shopmefy"
            })
          }
          
          # ===================================
          # VPC AND NETWORKING
          # ===================================
          
          resource "aws_vpc" "main" {
            cidr_block           = "10.0.0.0/16"
            enable_dns_hostnames = true
            enable_dns_support   = true
            
            tags = {
              Name = "${var.project_name}-vpc"
            }
          }
          
          resource "aws_internet_gateway" "main" {
            vpc_id = aws_vpc.main.id
            
            tags = {
              Name = "${var.project_name}-igw"
            }
          }
          
          resource "aws_subnet" "public" {
            count = 2
            
            vpc_id                  = aws_vpc.main.id
            cidr_block              = "10.0.${count.index + 1}.0/24"
            availability_zone       = data.aws_availability_zones.available.names[count.index]
            map_public_ip_on_launch = true
            
            tags = {
              Name = "${var.project_name}-public-subnet-${count.index + 1}"
            }
          }
          
          resource "aws_subnet" "private" {
            count = 2
            
            vpc_id            = aws_vpc.main.id
            cidr_block        = "10.0.${count.index + 10}.0/24"
            availability_zone = data.aws_availability_zones.available.names[count.index]
            
            tags = {
              Name = "${var.project_name}-private-subnet-${count.index + 1}"
            }
          }
          
          resource "aws_route_table" "public" {
            vpc_id = aws_vpc.main.id
            
            route {
              cidr_block = "0.0.0.0/0"
              gateway_id = aws_internet_gateway.main.id
            }
            
            tags = {
              Name = "${var.project_name}-public-rt"
            }
          }
          
          resource "aws_route_table_association" "public" {
            count = length(aws_subnet.public)
            
            subnet_id      = aws_subnet.public[count.index].id
            route_table_id = aws_route_table.public.id
          }
          
          # ===================================
          # SECURITY GROUPS
          # ===================================
          
          resource "aws_security_group" "web" {
            name_prefix = "${var.project_name}-web-"
            vpc_id      = aws_vpc.main.id
            description = "Security group for web server"
            
            # SSH
            ingress {
              from_port   = 22
              to_port     = 22
              protocol    = "tcp"
              cidr_blocks = ["0.0.0.0/0"]
              description = "SSH"
            }
            
            # HTTP
            ingress {
              from_port   = 80
              to_port     = 80
              protocol    = "tcp"
              cidr_blocks = ["0.0.0.0/0"]
              description = "HTTP"
            }
            
            # HTTPS
            ingress {
              from_port   = 443
              to_port     = 443
              protocol    = "tcp"
              cidr_blocks = ["0.0.0.0/0"]
              description = "HTTPS"
            }
            
            # Node.js Backend
            ingress {
              from_port   = 8080
              to_port     = 8080
              protocol    = "tcp"
              cidr_blocks = ["10.0.0.0/16"]
              description = "Backend API"
            }
            
            # React Frontend
            ingress {
              from_port   = 3000
              to_port     = 3000
              protocol    = "tcp"
              cidr_blocks = ["10.0.0.0/16"]
              description = "Frontend"
            }
            
            egress {
              from_port   = 0
              to_port     = 0
              protocol    = "-1"
              cidr_blocks = ["0.0.0.0/0"]
              description = "All outbound traffic"
            }
            
            tags = {
              Name = "${var.project_name}-web-sg"
            }
          }
          
          resource "aws_security_group" "database" {
            name_prefix = "${var.project_name}-db-"
            vpc_id      = aws_vpc.main.id
            description = "Security group for RDS database"
            
            ingress {
              from_port       = 5432
              to_port         = 5432
              protocol        = "tcp"
              security_groups = [aws_security_group.web.id]
              description     = "PostgreSQL from web servers"
            }
            
            tags = {
              Name = "${var.project_name}-db-sg"
            }
          }
          
          # ===================================
          # KEY PAIR
          # ===================================
          
          resource "aws_key_pair" "main" {
            key_name   = "${var.project_name}-key"
            public_key = file("~/.ssh/id_rsa.pub") # You'll need to generate this
            
            tags = {
              Name = "${var.project_name}-keypair"
            }
          }
          
          # ===================================
          # S3 BUCKET FOR DEPLOYMENTS
          # ===================================
          
          resource "aws_s3_bucket" "deployments" {
            bucket = "${var.project_name}-deployments-${random_id.bucket_suffix.hex}"
            
            tags = {
              Name = "${var.project_name}-deployments"
            }
          }
          
          resource "random_id" "bucket_suffix" {
            byte_length = 4
          }
          
          resource "aws_s3_bucket_versioning" "deployments" {
            bucket = aws_s3_bucket.deployments.id
            versioning_configuration {
              status = "Enabled"
            }
          }
          
          resource "aws_s3_bucket_server_side_encryption_configuration" "deployments" {
            bucket = aws_s3_bucket.deployments.id
            
            rule {
              apply_server_side_encryption_by_default {
                sse_algorithm = "AES256"
              }
            }
          }
          
          resource "aws_s3_bucket_public_access_block" "deployments" {
            bucket = aws_s3_bucket.deployments.id
            
            block_public_acls       = true
            block_public_policy     = true
            ignore_public_acls      = true
            restrict_public_buckets = true
          }
          
          # ===================================
          # RDS SUBNET GROUP
          # ===================================
          
          resource "aws_db_subnet_group" "main" {
            name       = "${var.project_name}-db-subnet-group"
            subnet_ids = aws_subnet.private[*].id
            
            tags = {
              Name = "${var.project_name}-db-subnet-group"
            }
          }
          
          # ===================================
          # RDS POSTGRESQL DATABASE
          # ===================================
          
          resource "aws_db_instance" "postgres" {
            identifier = "${var.project_name}-db"
            
            # Engine
            engine         = "postgres"
            engine_version = "15.4"
            instance_class = "db.t3.micro"
            
            # Storage
            allocated_storage     = 20
            max_allocated_storage = 100
            storage_type          = "gp2"
            storage_encrypted     = true
            
            # Database
            db_name  = "shopmefy"
            username = "shopmefy"
            password = random_password.db_password.result
            
            # Network
            db_subnet_group_name   = aws_db_subnet_group.main.name
            vpc_security_group_ids = [aws_security_group.database.id]
            publicly_accessible    = false
            
            # Backup
            backup_retention_period = 7
            backup_window          = "03:00-04:00"
            maintenance_window     = "sun:04:00-sun:05:00"
            
            # Monitoring
            monitoring_interval = 60
            monitoring_role_arn = aws_iam_role.rds_monitoring.arn
            
            # Other
            skip_final_snapshot = true
            deletion_protection = false
            
            tags = {
              Name = "${var.project_name}-database"
            }
          }
          
          # ===================================
          # IAM ROLE FOR RDS MONITORING
          # ===================================
          
          resource "aws_iam_role" "rds_monitoring" {
            name = "${var.project_name}-rds-monitoring-role"
            
            assume_role_policy = jsonencode({
              Version = "2012-10-17"
              Statement = [
                {
                  Action = "sts:AssumeRole"
                  Effect = "Allow"
                  Principal = {
                    Service = "monitoring.rds.amazonaws.com"
                  }
                }
              ]
            })
          }
          
          resource "aws_iam_role_policy_attachment" "rds_monitoring" {
            role       = aws_iam_role.rds_monitoring.name
            policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole"
          }
          
          # ===================================
          # IAM ROLE FOR EC2
          # ===================================
          
          resource "aws_iam_role" "ec2_role" {
            name = "${var.project_name}-ec2-role"
            
            assume_role_policy = jsonencode({
              Version = "2012-10-17"
              Statement = [
                {
                  Action = "sts:AssumeRole"
                  Effect = "Allow"
                  Principal = {
                    Service = "ec2.amazonaws.com"
                  }
                }
              ]
            })
          }
          
          resource "aws_iam_role_policy" "ec2_policy" {
            name = "${var.project_name}-ec2-policy"
            role = aws_iam_role.ec2_role.id
            
            policy = jsonencode({
              Version = "2012-10-17"
              Statement = [
                {
                  Effect = "Allow"
                  Action = [
                    "s3:GetObject",
                    "s3:ListBucket"
                  ]
                  Resource = [
                    aws_s3_bucket.deployments.arn,
                    "${aws_s3_bucket.deployments.arn}/*"
                  ]
                },
                {
                  Effect = "Allow"
                  Action = [
                    "secretsmanager:GetSecretValue"
                  ]
                  Resource = aws_secretsmanager_secret.db_credentials.arn
                },
                {
                  Effect = "Allow"
                  Action = [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents"
                  ]
                  Resource = "*"
                }
              ]
            })
          }
          
          resource "aws_iam_instance_profile" "ec2_profile" {
            name = "${var.project_name}-ec2-profile"
            role = aws_iam_role.ec2_role.name
          }
          
          # ===================================
          # USER DATA SCRIPT
          # ===================================
          
          locals {
            user_data = base64encode(templatefile("${path.module}/user_data.sh", {
              project_name = var.project_name
              s3_bucket    = aws_s3_bucket.deployments.bucket
              secret_arn   = aws_secretsmanager_secret.db_credentials.arn
              aws_region   = var.aws_region
            }))
          }
          
          # ===================================
          # EC2 INSTANCE
          # ===================================
          
          resource "aws_instance" "web" {
            ami                    = data.aws_ami.ubuntu.id
            instance_type          = var.instance_type
            key_name               = aws_key_pair.main.key_name
            vpc_security_group_ids = [aws_security_group.web.id]
            subnet_id              = aws_subnet.public[0].id
            iam_instance_profile   = aws_iam_instance_profile.ec2_profile.name
            
            user_data = local.user_data
            
            root_block_device {
              volume_type = "gp3"
              volume_size = 20
              encrypted   = true
            }
            
            tags = {
              Name = "${var.project_name}-web-server"
            }
          }
          
          # ===================================
          # ELASTIC IP
          # ===================================
          
          resource "aws_eip" "web" {
            instance = aws_instance.web.id
            domain   = "vpc"
            
            tags = {
              Name = "${var.project_name}-eip"
            }
          }
          
          # ===================================
          # OUTPUTS
          # ===================================
          
          output "web_public_ip" {
            description = "Public IP address of the web server"
            value       = aws_eip.web.public_ip
          }
          
          output "web_public_dns" {
            description = "Public DNS name of the web server"
            value       = aws_eip.web.public_dns
          }
          
          output "database_endpoint" {
            description = "RDS instance endpoint"
            value       = aws_db_instance.postgres.endpoint
            sensitive   = true
          }
          
          output "s3_bucket_name" {
            description = "S3 bucket name for deployments"
            value       = aws_s3_bucket.deployments.bucket
          }
          
          output "secret_manager_arn" {
            description = "AWS Secrets Manager ARN for database credentials"
            value       = aws_secretsmanager_secret.db_credentials.arn
          }
          
          output "ssh_command" {
            description = "SSH command to connect to the server"
            value       = "ssh -i ~/.ssh/id_rsa ubuntu@${aws_eip.web.public_ip}"
          }
          EOF

      - name: ðŸ“ Generate User Data Script
        run: |
          cat > user_data.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Update system
          apt-get update
          apt-get upgrade -y
          
          # Install required packages
          apt-get install -y curl wget git unzip nginx awscli
          
          # Install Node.js 20
          curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
          apt-get install -y nodejs
          
          # Install PM2 globally
          npm install -g pm2
          
          # Install Docker
          curl -fsSL https://get.docker.com -o get-docker.sh
          sh get-docker.sh
          usermod -aG docker ubuntu
          
          # Create shopme user
          useradd -m -s /bin/bash shopme
          usermod -aG sudo shopme
          usermod -aG docker shopme
          
          # Create directories
          mkdir -p /home/shopme/{backend,frontend}
          chown -R shopme:shopme /home/shopme
          
          # Configure AWS CLI for shopme user
          sudo -u shopme aws configure set region ${aws_region}
          
          # Create systemd service for auto-deployment
          cat > /etc/systemd/system/shopmefy-deploy.service << 'EOL'
          [Unit]
          Description=ShopMefy Auto Deploy Service
          After=network.target
          
          [Service]
          Type=oneshot
          User=shopme
          WorkingDirectory=/home/shopme
          ExecStart=/home/shopme/deploy.sh
          
          [Install]
          WantedBy=multi-user.target
          EOL
          
          # Create deployment script
          cat > /home/shopme/deploy.sh << 'EOL'
          #!/bin/bash
          set -e
          
          echo "Starting deployment..."
          
          # Download from S3
          aws s3 sync s3://${s3_bucket}/backend /home/shopme/backend --delete
          aws s3 sync s3://${s3_bucket}/frontend /home/shopme/frontend --delete
          
          # Backend deployment
          cd /home/shopme/backend
          npm install --production
          npm run build
          
          # PM2 deployment
          pm2 delete backend || true
          pm2 start npm --name backend -- start -- --port 8080
          pm2 save
          
          # Frontend deployment (if needed)
          cd /home/shopme/frontend
          npm install --production
          npm run build
          
          echo "Deployment completed successfully!"
          EOL
          
          chmod +x /home/shopme/deploy.sh
          chown shopme:shopme /home/shopme/deploy.sh
          
          # Configure Nginx
          cat > /etc/nginx/sites-available/shopmefy << 'EOL'
          server {
              listen 80;
              server_name _;
              
              location /api/ {
                  proxy_pass http://localhost:8080/api/;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
              
              location / {
                  proxy_pass http://localhost:3000/;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
          }
          EOL
          
          ln -sf /etc/nginx/sites-available/shopmefy /etc/nginx/sites-enabled/
          rm -f /etc/nginx/sites-enabled/default
          nginx -t
          systemctl restart nginx
          systemctl enable nginx
          
          # Enable auto-deployment service
          systemctl enable shopmefy-deploy.service
          
          # Setup PM2 startup
          sudo -u shopme pm2 startup systemd -u shopme --hp /home/shopme
          
          # Create environment file for database connection
          cat > /home/shopme/.env << 'EOL'
          NODE_ENV=production
          PORT=8080
          DATABASE_URL=postgresql://shopmefy:$(aws secretsmanager get-secret-value --secret-id ${secret_arn} --region ${aws_region} --query SecretString --output text | jq -r .password)@$(aws secretsmanager get-secret-value --secret-id ${secret_arn} --region ${aws_region} --query SecretString --output text | jq -r .host):5432/shopmefy
          EOL
          
          chown shopme:shopme /home/shopme/.env
          
          echo "Server setup completed successfully!"
          EOF

      - name: ðŸ”§ Terraform Init
        run: terraform init

      - name: ðŸ“‹ Terraform Plan
        if: github.event.inputs.action == 'plan'
        run: |
          terraform plan \
            -var="instance_type=${{ github.event.inputs.instance_type }}" \
            -out=tfplan

      - name: ðŸš€ Terraform Apply
        if: github.event.inputs.action == 'apply'
        run: |
          terraform apply \
            -var="instance_type=${{ github.event.inputs.instance_type }}" \
            -auto-approve

      - name: ðŸ’¥ Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        run: |
          terraform destroy \
            -var="instance_type=${{ github.event.inputs.instance_type }}" \
            -auto-approve

      - name: ðŸ“Š Show Outputs
        if: github.event.inputs.action == 'apply'
        run: |
          echo "## ðŸŽ‰ Infrastructure Deployed Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Connection Details:" >> $GITHUB_STEP_SUMMARY
          echo "- **Public IP**: $(terraform output -raw web_public_ip)" >> $GITHUB_STEP_SUMMARY
          echo "- **Public DNS**: $(terraform output -raw web_public_dns)" >> $GITHUB_STEP_SUMMARY
          echo "- **SSH Command**: \`$(terraform output -raw ssh_command)\`" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Bucket**: $(terraform output -raw s3_bucket_name)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”§ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Update your \`deploy.yml\` with the new S3 bucket name" >> $GITHUB_STEP_SUMMARY
          echo "2. Update your \`deploy.yml\` with the new EC2 IP address" >> $GITHUB_STEP_SUMMARY
          echo "3. Run your existing CI/CD pipeline to deploy the application" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ’° Estimated Monthly Cost: ~$27-30" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ” Save Secrets to GitHub
        if: github.event.inputs.action == 'apply'
        run: |
          echo "## ðŸ” Update these GitHub Secrets:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- \`S3_BUCKET_NAME\`: $(terraform output -raw s3_bucket_name)" >> $GITHUB_STEP_SUMMARY
          echo "- \`EC2_HOST\`: $(terraform output -raw web_public_ip)" >> $GITHUB_STEP_SUMMARY
          echo "- \`EC2_USER\`: ubuntu" >> $GITHUB_STEP_SUMMARY
          echo "- \`AWS_REGION\`: us-east-1" >> $GITHUB_STEP_SUMMARY 