name: ğŸš€ Deploy Application

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
      force_deploy:
        description: 'Force deploy even if infrastructure is stopped'
        required: false
        default: false
        type: boolean
      skip_health_check:
        description: 'Skip post-deployment health check'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  INSTANCE_ID: i-008b6c493b1f842a9
  FIXED_EIP_ALLOCATION: eipalloc-0001d20efe88091c7

jobs:
  pre-deploy-check:
    name: ğŸ” Pre-Deploy Infrastructure Check
    runs-on: ubuntu-latest
    environment: dev
    outputs:
      ec2_state: ${{ steps.check.outputs.EC2_STATE }}
      fixed_ip: ${{ steps.check.outputs.FIXED_IP }}
      can_deploy: ${{ steps.check.outputs.CAN_DEPLOY }}
      
    steps:
      - name: âš™ï¸ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ” Check Infrastructure Status
        id: check
        run: |
          echo "ğŸ” Checking infrastructure status before deployment..."
          
          # Check EC2 state
          EC2_STATE=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[0].Instances[0].State.Name" --output text)
          echo "EC2_STATE=$EC2_STATE" >> $GITHUB_OUTPUT
          echo "EC2 Instance: $EC2_STATE"
          
          # Get fixed IP
          FIXED_IP=$(aws ec2 describe-addresses --allocation-ids $FIXED_EIP_ALLOCATION --query "Addresses[0].PublicIp" --output text 2>/dev/null || echo "Not found")
          echo "FIXED_IP=$FIXED_IP" >> $GITHUB_OUTPUT
          echo "Fixed IP: $FIXED_IP"
          
          # Check if IP is associated
          CURRENT_ASSOCIATION=$(aws ec2 describe-addresses --allocation-ids $FIXED_EIP_ALLOCATION --query "Addresses[0].InstanceId" --output text 2>/dev/null || echo "None")
          echo "IP Association: $CURRENT_ASSOCIATION"
          
          # Determine if we can deploy
          if [ "$EC2_STATE" = "running" ] && [ "$CURRENT_ASSOCIATION" = "$INSTANCE_ID" ]; then
            echo "CAN_DEPLOY=true" >> $GITHUB_OUTPUT
            echo "âœ… Infrastructure is ready for deployment"
          elif [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "CAN_DEPLOY=force" >> $GITHUB_OUTPUT
            echo "âš ï¸ Force deploy requested - will attempt to start infrastructure first"
          else
            echo "CAN_DEPLOY=false" >> $GITHUB_OUTPUT
            echo "âŒ Infrastructure not ready for deployment"
            echo "EC2 State: $EC2_STATE, IP Associated: $CURRENT_ASSOCIATION"
          fi

      - name: ğŸ“Š Pre-Deploy Summary
        run: |
          echo "## ğŸ” Pre-Deploy Infrastructure Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“‹ Infrastructure Status:" >> $GITHUB_STEP_SUMMARY
          echo "- **EC2 Instance**: ${{ steps.check.outputs.EC2_STATE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Fixed IP**: ${{ steps.check.outputs.FIXED_IP }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Can Deploy**: ${{ steps.check.outputs.CAN_DEPLOY }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check.outputs.CAN_DEPLOY }}" = "false" ]; then
            echo "### âš ï¸ Action Required:" >> $GITHUB_STEP_SUMMARY
            echo "Infrastructure is not ready for deployment. Please:" >> $GITHUB_STEP_SUMMARY
            echo "1. Use **Infrastructure Control** workflow to start the infrastructure" >> $GITHUB_STEP_SUMMARY
            echo "2. Or enable **force_deploy** option to auto-start infrastructure" >> $GITHUB_STEP_SUMMARY
          fi

  start-infrastructure:
    name: ğŸš€ Start Infrastructure (if needed)
    needs: pre-deploy-check
    runs-on: ubuntu-latest
    environment: dev
    if: needs.pre-deploy-check.outputs.can_deploy == 'force'
    
    steps:
      - name: âš™ï¸ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸš€ Start EC2 and Associate IP
        run: |
          echo "ğŸš€ Starting infrastructure for forced deployment..."
          
          if [ "${{ needs.pre-deploy-check.outputs.ec2_state }}" = "stopped" ]; then
            echo "Starting EC2 instance..."
            aws ec2 start-instances --instance-ids $INSTANCE_ID
            
            echo "Waiting for instance to be running..."
            aws ec2 wait instance-running --instance-ids $INSTANCE_ID
            
            echo "Associating fixed Elastic IP..."
            aws ec2 associate-address --instance-id $INSTANCE_ID --allocation-id $FIXED_EIP_ALLOCATION
            
            echo "âœ… Infrastructure started successfully!"
            
            # Wait for SSH to be ready
            echo "â³ Waiting for SSH to be ready..."
            sleep 30
          else
            echo "âœ… EC2 already running, ensuring IP association..."
            aws ec2 associate-address --instance-id $INSTANCE_ID --allocation-id $FIXED_EIP_ALLOCATION || true
          fi

  deploy:
    name: ğŸš€ Deploy to EC2
    needs: [pre-deploy-check, start-infrastructure]
    runs-on: ubuntu-latest
    environment: dev
    if: always() && (needs.pre-deploy-check.outputs.can_deploy == 'true' || needs.pre-deploy-check.outputs.can_deploy == 'force')
    
    steps:
      - name: ğŸ¯ Set Environment
        run: |
          echo "DEPLOY_ENV=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          echo "FIXED_IP=${{ needs.pre-deploy-check.outputs.fixed_ip }}" >> $GITHUB_ENV
          echo "SKIP_HEALTH_CHECK=${{ github.event.inputs.skip_health_check }}" >> $GITHUB_ENV
          echo "Deploying to: ${{ needs.pre-deploy-check.outputs.fixed_ip }}"

      - name: ğŸ”‘ Prepare SSH Key
        run: |
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ec2_key.pem
          chmod 600 ec2_key.pem

      - name: ğŸ”— Test SSH Connection
        run: |
          echo "ğŸ”— Testing SSH connection before deployment..."
          
          # Test SSH with timeout
          timeout 30s ssh -i ec2_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@${{ env.FIXED_IP }} "echo 'SSH connection successful'" || {
            echo "âŒ SSH connection failed"
            echo "This might indicate:"
            echo "1. EC2 instance is still starting up"
            echo "2. Security group issues"
            echo "3. SSH key problems"
            exit 1
          }
          
          echo "âœ… SSH connection verified"

      - name: ğŸš€ Deploy Application to EC2
        run: |
          echo "ğŸš€ Starting ShopMefy deployment to ${{ env.FIXED_IP }}..."
          
          ssh -i ec2_key.pem -o StrictHostKeyChecking=no ubuntu@${{ env.FIXED_IP }} << 'DEPLOY_SCRIPT'
            set -e  # Exit on any error
            
            echo "ğŸš€ Starting ShopMefy deployment..."
            
            # Stop existing processes gracefully
            echo "ğŸ›‘ Stopping existing processes..."
            sudo pkill -f "node.*dist/index.js" || true
            sudo pkill -f "vite preview" || true
            sudo pkill -f npm || true
            sleep 5
            
            # Clone or update repository
            if [ -d "AI4Devs-finalproject" ]; then
              echo "ğŸ“¥ Updating existing repository..."
              cd AI4Devs-finalproject
              git fetch origin
              git reset --hard origin/main
              git clean -fd
            else
              echo "ğŸ“¥ Cloning repository..."
              git clone https://github.com/gelsogrove/AI4Devs-finalproject.git
              cd AI4Devs-finalproject
            fi
            
            # Backend deployment
            echo "ğŸ”§ Setting up backend..."
            cd backend
            
            # Install dependencies
            echo "ğŸ“¦ Installing backend dependencies..."
            npm ci --production --silent
            
            # Create backend .env
            echo "âš™ï¸ Creating backend .env..."
            cat > .env << EOF
          NODE_ENV=development
          PORT=8080
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          AWS_S3_BUCKET=${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION=us-east-1
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          PUBLIC_URL=http://${{ env.FIXED_IP }}
          SWAGGER_USER=${{ secrets.SWAGGER_USER }}
          SWAGGER_PASSWORD=${{ secrets.SWAGGER_PASSWORD }}
          EOF
            
            # Build backend
            echo "ğŸ—ï¸ Building backend..."
            npm run build
            
            # Database operations
            echo "ğŸ—„ï¸ Setting up database..."
            echo "Running Prisma migrations..."
            npx prisma migrate deploy
            
            echo "Seeding database..."
            npx prisma db seed || {
              echo "âš ï¸ Database seeding failed - this might be expected if data already exists"
            }
            
            # Start backend
            echo "ğŸš€ Starting backend service..."
            nohup npm run start > ../backend.log 2>&1 &
            BACKEND_PID=$!
            echo $BACKEND_PID > ../backend.pid
            echo "Backend started with PID: $BACKEND_PID"
            
            # Frontend deployment
            echo "ğŸ”§ Setting up frontend..."
            cd ../frontend
            
            # Install dependencies
            echo "ğŸ“¦ Installing frontend dependencies..."
            npm ci --silent
            
            # Create frontend .env
            echo "âš™ï¸ Creating frontend .env..."
            echo "VITE_API_URL=http://${{ env.FIXED_IP }}" > .env
            
            # Build frontend
            echo "ğŸ—ï¸ Building frontend..."
            npm run build
            
            # Start frontend
            echo "ğŸš€ Starting frontend service..."
            nohup npx vite preview --host 0.0.0.0 --port 3000 > ../frontend.log 2>&1 &
            FRONTEND_PID=$!
            echo $FRONTEND_PID > ../frontend.pid
            echo "Frontend started with PID: $FRONTEND_PID"
            
            # Configure Nginx reverse proxy
            echo "ğŸ”§ Configuring Nginx reverse proxy..."
            sudo tee /etc/nginx/sites-available/default > /dev/null << 'NGINX_CONFIG'
          server {
              listen 80;
              server_name _;
              
              # Frontend
              location / {
                  proxy_pass http://localhost:3000;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
              
              # Backend API
              location /api {
                  proxy_pass http://localhost:8080;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
          }
          NGINX_CONFIG
            
            # Test and restart Nginx
            echo "ğŸ”„ Testing and restarting Nginx..."
            sudo nginx -t
            sudo systemctl restart nginx
            sudo systemctl enable nginx
            
            # Wait for services to start
            echo "â³ Waiting for services to initialize..."
            sleep 20
            
            # Verify processes are running
            echo "ğŸ“Š Verifying running processes..."
            BACKEND_RUNNING=$(ps -p $BACKEND_PID > /dev/null 2>&1 && echo "âœ…" || echo "âŒ")
            FRONTEND_RUNNING=$(ps -p $FRONTEND_PID > /dev/null 2>&1 && echo "âœ…" || echo "âŒ")
            
            echo "Backend process: $BACKEND_RUNNING (PID: $BACKEND_PID)"
            echo "Frontend process: $FRONTEND_RUNNING (PID: $FRONTEND_PID)"
            
            echo "âœ… Deployment completed successfully!"
            echo "ğŸŒ Application: http://${{ env.FIXED_IP }}"
            echo "ğŸ”— API: http://${{ env.FIXED_IP }}/api"
            
            # Show final process status
            echo "ğŸ“Š Final process status:"
            ps aux | grep -E "(node|vite)" | grep -v grep | head -10 || echo "No processes found"
          DEPLOY_SCRIPT

      - name: ğŸ¥ Post-Deploy Health Check
        if: env.SKIP_HEALTH_CHECK != 'true'
        run: |
          echo "ğŸ¥ Performing comprehensive health check..."
          
          # Wait for services to fully initialize
          echo "â³ Waiting for services to fully start..."
          sleep 15
          
          # Test endpoints with retries
          echo "ğŸŒ Testing application endpoints..."
          
          # Function to test endpoint with retries
          test_endpoint() {
            local url=$1
            local name=$2
            local max_attempts=5
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Testing $name (attempt $attempt/$max_attempts)..."
              status=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "$url" || echo "000")
              
              if [ "$status" = "200" ]; then
                echo "âœ… $name: HTTP $status"
                return 0
              else
                echo "âš ï¸ $name: HTTP $status"
                if [ $attempt -lt $max_attempts ]; then
                  echo "Retrying in 10 seconds..."
                  sleep 10
                fi
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "âŒ $name: Failed after $max_attempts attempts"
            return 1
          }
          
          # Test all endpoints
          FRONTEND_OK=false
          API_HEALTH_OK=false
          API_SERVICES_OK=false
          
          test_endpoint "http://${{ env.FIXED_IP }}/" "Frontend" && FRONTEND_OK=true
          test_endpoint "http://${{ env.FIXED_IP }}/api/health" "API Health" && API_HEALTH_OK=true
          test_endpoint "http://${{ env.FIXED_IP }}/api/services" "API Services" && API_SERVICES_OK=true
          
          # Determine overall health
          if [ "$FRONTEND_OK" = true ] && [ "$API_HEALTH_OK" = true ] && [ "$API_SERVICES_OK" = true ]; then
            echo "HEALTH_STATUS=healthy" >> $GITHUB_ENV
            echo "âœ… All health checks passed!"
          elif [ "$FRONTEND_OK" = true ] && [ "$API_HEALTH_OK" = true ]; then
            echo "HEALTH_STATUS=partial" >> $GITHUB_ENV
            echo "âš ï¸ Core services healthy, some API endpoints may need time"
          else
            echo "HEALTH_STATUS=unhealthy" >> $GITHUB_ENV
            echo "âŒ Health checks failed - manual investigation required"
          fi
          
          # Additional diagnostic info
          echo ""
          echo "ğŸ” Additional diagnostics:"
          
          # Test SSH and get process info
          ssh -i ec2_key.pem -o StrictHostKeyChecking=no ubuntu@${{ env.FIXED_IP }} << 'DIAG_SCRIPT'
            echo "ğŸ“Š Current processes:"
            ps aux | grep -E "(node|vite|nginx)" | grep -v grep || echo "No relevant processes found"
            
            echo ""
            echo "ğŸ” Service status:"
            sudo systemctl status nginx --no-pager -l || true
            
            echo ""
            echo "ğŸ“ Recent logs (last 10 lines):"
            echo "Backend log:"
            tail -10 ~/AI4Devs-finalproject/backend.log 2>/dev/null || echo "No backend log found"
            echo ""
            echo "Frontend log:"
            tail -10 ~/AI4Devs-finalproject/frontend.log 2>/dev/null || echo "No frontend log found"
          DIAG_SCRIPT

      - name: ğŸ§¹ Cleanup
        if: always()
        run: |
          rm -f ec2_key.pem

      - name: ğŸ“Š Deployment Summary
        run: |
          echo "## ğŸ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“‹ Deployment Details:" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ env.DEPLOY_ENV }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Server**: ${{ env.FIXED_IP }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Time**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Status**: ${{ env.HEALTH_STATUS || 'unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ğŸ”— Access Your Application:" >> $GITHUB_STEP_SUMMARY
          echo "- **ğŸŒ Application**: http://${{ env.FIXED_IP }}/" >> $GITHUB_STEP_SUMMARY
          echo "- **ğŸ”Œ API**: http://${{ env.FIXED_IP }}/api" >> $GITHUB_STEP_SUMMARY
          echo "- **â¤ï¸ API Health**: http://${{ env.FIXED_IP }}/api/health" >> $GITHUB_STEP_SUMMARY
          echo "- **ğŸ“š Swagger Docs**: http://${{ env.FIXED_IP }}/api-docs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ env.HEALTH_STATUS }}" = "healthy" ]; then
            echo "### âœ… Status: All Systems Operational" >> $GITHUB_STEP_SUMMARY
            echo "Your application is fully deployed and all health checks passed!" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ env.HEALTH_STATUS }}" = "partial" ]; then
            echo "### âš ï¸ Status: Partially Healthy" >> $GITHUB_STEP_SUMMARY
            echo "Core services are running, but some endpoints may need more time to initialize." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Status: Health Check Issues" >> $GITHUB_STEP_SUMMARY
            echo "Some services may not be responding correctly. Check the logs for details." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ¯ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ§ª Test the application functionality" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“Š Monitor performance and logs" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ” SSH access: \`ssh -i key.pem ubuntu@${{ env.FIXED_IP }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ’° Use **Infrastructure Control â†’ stop** to save costs when not in use" >> $GITHUB_STEP_SUMMARY

