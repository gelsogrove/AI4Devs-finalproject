# Complete Infrastructure Destruction for ShopMefy
# This workflow completely destroys ALL AWS infrastructure and resources
# 
# ‚ö†Ô∏è  DANGER ZONE ‚ö†Ô∏è
# This will permanently delete:
# - All EC2 instances and data
# - All RDS databases and data  
# - All S3 buckets and content
# - All networking (VPC, subnets, security groups)
# - All secrets and keys
# - Everything related to shopmefy-dev*
#
# üí∞ RESULT: Zero AWS costs after completion
# üîÑ RECOVERY: You can recreate everything with infra-deploy.yml
#
# REQUIRED GITHUB SECRETS:
# - AWS_ACCESS_KEY_ID: AWS access key for resource deletion
# - AWS_SECRET_ACCESS_KEY: AWS secret key for resource deletion

name: üóëÔ∏è Destroy Infrastructure

on:
  workflow_dispatch:
    inputs:
      confirm_destruction:
        description: 'Type "DESTROY" to confirm complete infrastructure deletion'
        required: true
        type: string
      force_delete:
        description: 'Force delete even if resources have dependencies'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1

jobs:
  destroy:
    name: üßπ Complete Infrastructure Destruction
    runs-on: ubuntu-latest
    environment: dev
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: ‚ö†Ô∏è Validate Destruction Confirmation
        run: |
          if [ "${{ github.event.inputs.confirm_destruction }}" != "DESTROY" ]; then
            echo "‚ùå ERROR: You must type 'DESTROY' to confirm infrastructure deletion"
            echo "üõ°Ô∏è This safety check prevents accidental destruction"
            exit 1
          fi
          echo "‚úÖ Destruction confirmed - proceeding with complete cleanup"

      - name: ‚öôÔ∏è Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üßπ ENHANCED INFRASTRUCTURE DESTRUCTION
        run: |
          echo "üßπ ENHANCED CLEANUP STARTING..."
          echo "üóëÔ∏è This will delete ALL shopmefy-dev* resources"
          echo "üí∞ After this, you'll have ZERO AWS costs"
          echo ""
          
          # Install AWS CLI if not available
          if ! command -v aws &> /dev/null; then
            echo "Installing AWS CLI..."
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install
          fi
          
          # Set AWS region
          export AWS_DEFAULT_REGION=${{ env.AWS_REGION }}
          
          echo "üîç Finding ALL shopmefy-dev* resources across AWS..."
          
          # Terminate EC2 instances first (most important)
          echo "üñ•Ô∏è Terminating EC2 instances..."
          # Multiple search criteria for EC2
          EC2_BY_TAG=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=shopmefy-dev*" "Name=instance-state-name,Values=running,stopped,stopping" --query "Reservations[].Instances[].InstanceId" --output text)
          EC2_BY_NAME=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=*shopmefy*" "Name=instance-state-name,Values=running,stopped,stopping" --query "Reservations[].Instances[].InstanceId" --output text)
          # Search by any tag containing shopmefy
          EC2_BY_ANY_TAG=$(aws ec2 describe-instances --query "Reservations[].Instances[?Tags && (Tags[?contains(Value, 'shopmefy')] || Tags[?contains(Key, 'shopmefy')])].InstanceId" --output text)
          
          # Combine and deduplicate
          ALL_INSTANCES="$EC2_BY_TAG $EC2_BY_NAME $EC2_BY_ANY_TAG"
          INSTANCES=$(echo $ALL_INSTANCES | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          echo "Found EC2 instances: $INSTANCES"
          
          if [ ! -z "$INSTANCES" ]; then
            echo "Terminating instances: $INSTANCES"
            aws ec2 terminate-instances --instance-ids $INSTANCES || echo "Some instances failed to terminate"
            echo "Waiting for instances to terminate..."
            aws ec2 wait instance-terminated --instance-ids $INSTANCES || echo "Wait timeout, continuing..."
          fi
          
          # Delete Elastic IPs with enhanced search
          echo "üéØ Deleting Elastic IPs..."
          # Search by tags
          EIPS_BY_TAG=$(aws ec2 describe-addresses --filters "Name=tag:Name,Values=shopmefy-dev*" --query "Addresses[].AllocationId" --output text)
          EIPS_BY_ANY_TAG=$(aws ec2 describe-addresses --query "Addresses[?Tags && (Tags[?contains(Value, 'shopmefy')] || Tags[?contains(Key, 'shopmefy')])].AllocationId" --output text)
          # Search by instance association
          EIPS_BY_INSTANCE=""
          for instance in $INSTANCES; do
            if [ ! -z "$instance" ]; then
              INSTANCE_EIPS=$(aws ec2 describe-addresses --filters "Name=instance-id,Values=$instance" --query "Addresses[].AllocationId" --output text)
              EIPS_BY_INSTANCE="$EIPS_BY_INSTANCE $INSTANCE_EIPS"
            fi
          done
          # Search unassociated EIPs that might be ours
          UNASSOC_EIPS=$(aws ec2 describe-addresses --query "Addresses[?!InstanceId].AllocationId" --output text)
          for ueip in $UNASSOC_EIPS; do
            if [ ! -z "$ueip" ]; then
              # Get the EIP details to check if it might be ours
              EIP_TAGS=$(aws ec2 describe-addresses --allocation-ids $ueip --query "Addresses[0].Tags[?Key=='Name'].Value" --output text 2>/dev/null || echo "")
              EIP_DOMAIN=$(aws ec2 describe-addresses --allocation-ids $ueip --query "Addresses[0].Domain" --output text 2>/dev/null || echo "")
              if [[ "$EIP_TAGS" == *"shopmefy"* ]] || [[ "$EIP_DOMAIN" == "vpc" ]]; then
                echo "Found potentially related EIP: $ueip"
                EIPS_BY_INSTANCE="$EIPS_BY_INSTANCE $ueip"
              fi
            fi
          done
          
          # Combine all EIPs and remove duplicates
          ALL_EIPS="$EIPS_BY_TAG $EIPS_BY_ANY_TAG $EIPS_BY_INSTANCE"
          EIPS=$(echo $ALL_EIPS | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          echo "Found EIPs to release: $EIPS"
          
          for eip in $EIPS; do
            if [ ! -z "$eip" ]; then
              echo "Releasing EIP: $eip"
              aws ec2 release-address --allocation-id $eip || echo "Failed to release $eip"
            fi
          done
          
          # Delete RDS instances with enhanced search
          echo "üóÑÔ∏è Deleting RDS instances..."
          RDS_BY_NAME=$(aws rds describe-db-instances --query "DBInstances[?starts_with(DBInstanceIdentifier, 'shopmefy-dev')].DBInstanceIdentifier" --output text)
          RDS_BY_PATTERN=$(aws rds describe-db-instances --query "DBInstances[?contains(DBInstanceIdentifier, 'shopmefy')].DBInstanceIdentifier" --output text)
          ALL_RDS="$RDS_BY_NAME $RDS_BY_PATTERN"
          RDS_INSTANCES=$(echo $ALL_RDS | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          echo "Found RDS instances: $RDS_INSTANCES"
          
          for db in $RDS_INSTANCES; do
            if [ ! -z "$db" ]; then
              echo "Deleting RDS instance: $db"
              aws rds delete-db-instance --db-instance-identifier $db --skip-final-snapshot --delete-automated-backups || echo "Failed to delete $db"
            fi
          done
          
          # Wait for RDS deletion
          if [ ! -z "$RDS_INSTANCES" ]; then
            echo "Waiting for RDS instances to be deleted..."
            sleep 60
          fi
          
          # Delete DB Subnet Groups with enhanced search
          echo "üîó Deleting DB Subnet Groups..."
          DB_SG_BY_NAME=$(aws rds describe-db-subnet-groups --query "DBSubnetGroups[?starts_with(DBSubnetGroupName, 'shopmefy-dev')].DBSubnetGroupName" --output text)
          DB_SG_BY_PATTERN=$(aws rds describe-db-subnet-groups --query "DBSubnetGroups[?contains(DBSubnetGroupName, 'shopmefy')].DBSubnetGroupName" --output text)
          ALL_DB_SG="$DB_SG_BY_NAME $DB_SG_BY_PATTERN"
          DB_SUBNET_GROUPS=$(echo $ALL_DB_SG | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          for sg in $DB_SUBNET_GROUPS; do
            if [ ! -z "$sg" ]; then
              echo "Deleting DB Subnet Group: $sg"
              aws rds delete-db-subnet-group --db-subnet-group-name $sg || echo "Failed to delete $sg"
            fi
          done
          
          # Delete S3 buckets with enhanced search
          echo "üóëÔ∏è Deleting S3 buckets and ALL content..."
          S3_BY_NAME=$(aws s3api list-buckets --query "Buckets[?starts_with(Name, 'shopmefy-dev')].Name" --output text)
          S3_BY_PATTERN=$(aws s3api list-buckets --query "Buckets[?contains(Name, 'shopmefy')].Name" --output text)
          ALL_S3="$S3_BY_NAME $S3_BY_PATTERN"
          S3_BUCKETS=$(echo $ALL_S3 | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          echo "Found S3 buckets: $S3_BUCKETS"
          
          for bucket in $S3_BUCKETS; do
            if [ ! -z "$bucket" ]; then
              echo "Emptying and deleting S3 bucket: $bucket"
              aws s3 rm s3://$bucket --recursive || echo "Failed to empty $bucket"
              aws s3api delete-bucket --bucket $bucket || echo "Failed to delete $bucket"
            fi
          done
          
          # Delete Secrets Manager secrets with enhanced search
          echo "üîê Deleting Secrets Manager secrets..."
          SECRETS_BY_NAME=$(aws secretsmanager list-secrets --query "SecretList[?starts_with(Name, 'shopmefy-dev')].Name" --output text)
          SECRETS_BY_PATTERN=$(aws secretsmanager list-secrets --query "SecretList[?contains(Name, 'shopmefy')].Name" --output text)
          ALL_SECRETS="$SECRETS_BY_NAME $SECRETS_BY_PATTERN"
          SECRETS=$(echo $ALL_SECRETS | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          for secret in $SECRETS; do
            if [ ! -z "$secret" ]; then
              echo "Deleting secret: $secret"
              aws secretsmanager delete-secret --secret-id $secret --force-delete-without-recovery || echo "Failed to delete $secret"
            fi
          done
          
          # Delete Key Pairs with enhanced search
          echo "üîë Deleting Key Pairs..."
          KEYS_BY_NAME=$(aws ec2 describe-key-pairs --query "KeyPairs[?starts_with(KeyName, 'shopmefy-dev')].KeyName" --output text)
          KEYS_BY_PATTERN=$(aws ec2 describe-key-pairs --query "KeyPairs[?contains(KeyName, 'shopmefy')].KeyName" --output text)
          ALL_KEYS="$KEYS_BY_NAME $KEYS_BY_PATTERN"
          KEY_PAIRS=$(echo $ALL_KEYS | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          for key in $KEY_PAIRS; do
            if [ ! -z "$key" ]; then
              echo "Deleting key pair: $key"
              aws ec2 delete-key-pair --key-name $key || echo "Failed to delete $key"
            fi
          done
          
          # Wait longer for instances to be fully terminated
          echo "‚è≥ Waiting for all instances to be fully terminated..."
          sleep 60
          
          # Delete Network Interfaces (ENIs) with enhanced search
          echo "üîå Deleting Network Interfaces..."
          ENIS_BY_TAG=$(aws ec2 describe-network-interfaces --filters "Name=tag:Name,Values=shopmefy-dev*" --query "NetworkInterfaces[?Status!='in-use'].NetworkInterfaceId" --output text)
          ENIS_BY_ANY_TAG=$(aws ec2 describe-network-interfaces --query "NetworkInterfaces[?Status!='in-use' && Tags && (Tags[?contains(Value, 'shopmefy')] || Tags[?contains(Key, 'shopmefy')])].NetworkInterfaceId" --output text)
          ENIS_BY_DESC=$(aws ec2 describe-network-interfaces --query "NetworkInterfaces[?Status!='in-use' && contains(Description, 'shopmefy')].NetworkInterfaceId" --output text)
          ALL_ENIS="$ENIS_BY_TAG $ENIS_BY_ANY_TAG $ENIS_BY_DESC"
          ENIS=$(echo $ALL_ENIS | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          for eni in $ENIS; do
            if [ ! -z "$eni" ]; then
              echo "Deleting network interface: $eni"
              aws ec2 delete-network-interface --network-interface-id $eni || echo "Failed to delete $eni"
            fi
          done
          
          # Delete Security Groups with SUPER enhanced search
          echo "üõ°Ô∏è Deleting Security Groups..."
          sleep 30  # Additional wait
          
          # Find Security Groups by multiple criteria
          # 1. By tags
          SG_BY_TAGS=$(aws ec2 describe-security-groups --filters "Name=tag:Name,Values=shopmefy-dev*" --query "SecurityGroups[?GroupName!='default'].GroupId" --output text)
          SG_BY_ANY_TAG=$(aws ec2 describe-security-groups --query "SecurityGroups[?GroupName!='default' && Tags && (Tags[?contains(Value, 'shopmefy')] || Tags[?contains(Key, 'shopmefy')])].GroupId" --output text)
          # 2. By group name pattern
          SG_BY_NAME=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=shopmefy-dev*" --query "SecurityGroups[].GroupId" --output text)
          SG_BY_NAME_PATTERN=$(aws ec2 describe-security-groups --query "SecurityGroups[?contains(GroupName, 'shopmefy') && GroupName!='default'].GroupId" --output text)
          # 3. By description containing shopmefy
          SG_BY_DESC=$(aws ec2 describe-security-groups --query "SecurityGroups[?contains(Description, 'shopmefy-dev') && GroupName!='default'].GroupId" --output text)
          SG_BY_DESC_PATTERN=$(aws ec2 describe-security-groups --query "SecurityGroups[?contains(Description, 'shopmefy') && GroupName!='default'].GroupId" --output text)
          # 4. By VPC association (find SGs in our VPCs)
          SG_BY_VPC=""
          VPCS_FOR_SG=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=shopmefy-dev*" --query "Vpcs[].VpcId" --output text)
          VPCS_BY_PATTERN=$(aws ec2 describe-vpcs --query "Vpcs[?Tags && (Tags[?contains(Value, 'shopmefy')] || Tags[?contains(Key, 'shopmefy')])].VpcId" --output text)
          ALL_VPCS_FOR_SG="$VPCS_FOR_SG $VPCS_BY_PATTERN"
          VPCS_FOR_SG=$(echo $ALL_VPCS_FOR_SG | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          for vpc in $VPCS_FOR_SG; do
            if [ ! -z "$vpc" ]; then
              VPC_SGS=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$vpc" --query "SecurityGroups[?GroupName!='default'].GroupId" --output text)
              SG_BY_VPC="$SG_BY_VPC $VPC_SGS"
            fi
          done
          
          # Combine all results and remove duplicates
          ALL_SECURITY_GROUPS="$SG_BY_TAGS $SG_BY_ANY_TAG $SG_BY_NAME $SG_BY_NAME_PATTERN $SG_BY_DESC $SG_BY_DESC_PATTERN $SG_BY_VPC"
          SECURITY_GROUPS=$(echo $ALL_SECURITY_GROUPS | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          
          echo "Found Security Groups to delete: $SECURITY_GROUPS"
          
          # Try to delete security groups multiple times (dependencies)
          for attempt in 1 2 3; do
            echo "Security Groups deletion attempt $attempt..."
            for sg in $SECURITY_GROUPS; do
              if [ ! -z "$sg" ]; then
                # Check if SG still exists
                SG_EXISTS=$(aws ec2 describe-security-groups --group-ids $sg --query "SecurityGroups[0].GroupId" --output text 2>/dev/null || echo "")
                if [ ! -z "$SG_EXISTS" ]; then
                  SG_NAME=$(aws ec2 describe-security-groups --group-ids $sg --query "SecurityGroups[0].GroupName" --output text 2>/dev/null || echo "unknown")
                  echo "Deleting security group: $sg ($SG_NAME)"
                  aws ec2 delete-security-group --group-id $sg || echo "Failed to delete $sg (may have dependencies)"
                fi
              fi
            done
            if [ $attempt -lt 3 ]; then
              echo "Waiting 30 seconds before next attempt..."
              sleep 30
            fi
          done
          
          # Delete VPC and related resources
          echo "üåê Deleting VPC resources..."
          VPCS=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=shopmefy-dev*" --query "Vpcs[].VpcId" --output text)
          for vpc in $VPCS; do
            if [ ! -z "$vpc" ]; then
              echo "Deleting VPC: $vpc"
              
              # Delete NAT Gateways first
              NAT_GATEWAYS=$(aws ec2 describe-nat-gateways --filter "Name=vpc-id,Values=$vpc" --query "NatGateways[?State!='deleted'].NatGatewayId" --output text)
              for nat in $NAT_GATEWAYS; do
                if [ ! -z "$nat" ]; then
                  echo "Deleting NAT Gateway: $nat"
                  aws ec2 delete-nat-gateway --nat-gateway-id $nat
                fi
              done
              
              # Wait for NAT Gateways to be deleted
              if [ ! -z "$NAT_GATEWAYS" ]; then
                echo "Waiting for NAT Gateways to be deleted..."
                sleep 60
              fi
              
              # Delete Network ACLs (except default)
              echo "üõ°Ô∏è Deleting Network ACLs..."
              NETWORK_ACLS=$(aws ec2 describe-network-acls --filters "Name=vpc-id,Values=$vpc" --query "NetworkAcls[?IsDefault==\`false\`].NetworkAclId" --output text)
              for acl in $NETWORK_ACLS; do
                if [ ! -z "$acl" ]; then
                  echo "Deleting Network ACL: $acl"
                  aws ec2 delete-network-acl --network-acl-id $acl || echo "Failed to delete $acl"
                fi
              done
              
              # Delete VPC Endpoints
              echo "üîó Deleting VPC Endpoints..."
              VPC_ENDPOINTS=$(aws ec2 describe-vpc-endpoints --filters "Name=vpc-id,Values=$vpc" --query "VpcEndpoints[].VpcEndpointId" --output text)
              for endpoint in $VPC_ENDPOINTS; do
                if [ ! -z "$endpoint" ]; then
                  echo "Deleting VPC Endpoint: $endpoint"
                  aws ec2 delete-vpc-endpoint --vpc-endpoint-id $endpoint || echo "Failed to delete $endpoint"
                fi
              done
              
              # Delete route table associations and route tables
              ROUTE_TABLES=$(aws ec2 describe-route-tables --filters "Name=vpc-id,Values=$vpc" --query "RouteTables[?Associations[0].Main!=\`true\`].RouteTableId" --output text)
              for rt in $ROUTE_TABLES; do
                if [ ! -z "$rt" ]; then
                  # Disassociate route tables
                  ASSOCIATIONS=$(aws ec2 describe-route-tables --route-table-ids $rt --query "RouteTables[].Associations[?Main!=\`true\`].RouteTableAssociationId" --output text)
                  for assoc in $ASSOCIATIONS; do
                    if [ ! -z "$assoc" ]; then
                      echo "Disassociating route table: $assoc"
                      aws ec2 disassociate-route-table --association-id $assoc || echo "Failed to disassociate $assoc"
                    fi
                  done
                  echo "Deleting route table: $rt"
                  aws ec2 delete-route-table --route-table-id $rt || echo "Failed to delete $rt"
                fi
              done
              
              # Delete subnets
              SUBNETS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$vpc" --query "Subnets[].SubnetId" --output text)
              for subnet in $SUBNETS; do
                if [ ! -z "$subnet" ]; then
                  echo "Deleting subnet: $subnet"
                  aws ec2 delete-subnet --subnet-id $subnet || echo "Failed to delete $subnet"
                fi
              done
              
              # Delete internet gateway
              IGWS=$(aws ec2 describe-internet-gateways --filters "Name=attachment.vpc-id,Values=$vpc" --query "InternetGateways[].InternetGatewayId" --output text)
              for igw in $IGWS; do
                if [ ! -z "$igw" ]; then
                  echo "Detaching and deleting internet gateway: $igw"
                  aws ec2 detach-internet-gateway --internet-gateway-id $igw --vpc-id $vpc || echo "Failed to detach $igw"
                  aws ec2 delete-internet-gateway --internet-gateway-id $igw || echo "Failed to delete $igw"
                fi
              done
              
              # Finally delete VPC
              echo "Deleting VPC: $vpc"
              aws ec2 delete-vpc --vpc-id $vpc || echo "Failed to delete $vpc"
            fi
          done
          
          # Delete CloudWatch Log Groups
          echo "üìä Deleting CloudWatch Log Groups..."
          LOG_GROUPS=$(aws logs describe-log-groups --log-group-name-prefix "/aws/ec2/shopmefy-dev" --query "logGroups[].logGroupName" --output text)
          for lg in $LOG_GROUPS; do
            if [ ! -z "$lg" ]; then
              echo "Deleting log group: $lg"
              aws logs delete-log-group --log-group-name $lg || echo "Failed to delete $lg"
            fi
          done
          
          echo ""
          echo "üéâ COMPLETE INFRASTRUCTURE DESTRUCTION FINISHED!"
          echo "üóëÔ∏è ALL shopmefy-dev* resources have been permanently removed"
          echo "üí∞ Zero AWS costs - No resources left running"
          echo "üîÑ You can recreate everything with infra-apply.yml anytime"
          echo ""
          echo "## üóëÔ∏è Complete Infrastructure Destruction Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Everything Permanently Removed:" >> $GITHUB_STEP_SUMMARY
          echo "- üñ•Ô∏è **EC2 instances** - Terminated and removed" >> $GITHUB_STEP_SUMMARY
          echo "- üóÑÔ∏è **RDS databases** - Deleted with all data" >> $GITHUB_STEP_SUMMARY
          echo "- üóëÔ∏è **S3 buckets** - Emptied and deleted completely" >> $GITHUB_STEP_SUMMARY
          echo "- üîê **Secrets Manager** - All secrets removed" >> $GITHUB_STEP_SUMMARY
          echo "- üîë **SSH Key Pairs** - Deleted" >> $GITHUB_STEP_SUMMARY
          echo "- üîå **Network Interfaces** - Cleaned up" >> $GITHUB_STEP_SUMMARY
          echo "- üõ°Ô∏è **Security Groups** - Removed" >> $GITHUB_STEP_SUMMARY
          echo "- üõ°Ô∏è **Network ACLs** - Custom ACLs deleted" >> $GITHUB_STEP_SUMMARY
          echo "- üîó **VPC Endpoints** - All endpoints removed" >> $GITHUB_STEP_SUMMARY
          echo "- üåê **VPC & Networking** - Complete network cleanup" >> $GITHUB_STEP_SUMMARY
          echo "- üìä **CloudWatch Logs** - Log groups deleted" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üí∞ Final Result:" >> $GITHUB_STEP_SUMMARY
          echo "- **Zero AWS costs** - No resources left running" >> $GITHUB_STEP_SUMMARY
          echo "- **Clean slate** - Ready for fresh deployment anytime" >> $GITHUB_STEP_SUMMARY
          echo "- **Complete destruction** - All shopmefy infrastructure permanently removed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Recovery:" >> $GITHUB_STEP_SUMMARY
          echo "- Use **infra-deploy.yml** to recreate complete infrastructure" >> $GITHUB_STEP_SUMMARY
          echo "- All configurations will be restored from Terraform" >> $GITHUB_STEP_SUMMARY
          echo "- Fresh start with zero legacy issues" >> $GITHUB_STEP_SUMMARY 